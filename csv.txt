type MovieData struct {
	id int
	title string
	voteAverage float64
	voteCount int
	status string
	release_date string
	revenue int
	length int
	adult bool
	backdrop_path string
	budget int
	homepage string
	imdbId string
	original_language string
	original_title string
	overview string
	popularity string
	poster_path string
	tagline string
	genres string
	production_companies string
	production_countries string
	spoken_languages string
	keywords string
}

func openDataBase() *sql.DB {
	if _, err := os.Stat("movies.db"); err == nil {
		db, err := sql.Open("sqlite3", "/data/movies.db")
		
		if err != nil {
            fmt.Println(err)
        }
        return db
	}else {
		db, err := sql.Open("sqlite3", "data/movies.db")
		
		if err != nil {
            fmt.Println(err)
        }
		createTable(db)
        return db
	}
}

func stringToFloat(s string) (data float64) {
	f, err := strconv.ParseFloat(s, 64)
	if(err != nil) {
		panic(err)
	}
	return f
}

func stringToInt(s string) (data int) {
	s = strings.TrimSuffix(s, ".0")
	i, err := strconv.Atoi(s)
	if(err != nil) {
		panic(err)
	}
	return i
}

func stringToBool(s string) (data bool) {
	b, err := strconv.ParseBool(s)
	if(err != nil) {
		panic(err)
	}
	return b
}

func parseCvs(filePath string) ([][]string, []string) {
	file, err := os.Open(filePath)

	if err != nil {
		log.Fatal("CSV file problem", err)
	}

	defer file.Close()

	cvsReader := csv.NewReader(file)

	var records [][]string
	
	for {
		record, err := cvsReader.Read()

		if err == io.EOF {
			break
		}
	
		if err != nil {
			log.Fatal("cvsReader.Read() file problem", err)
		}
		
		records = append(records, record)
	}
	return records[1:], records[0]
}

func parseMovies(records [][]string) []MovieData {
	var movies []MovieData

	for _, record := range records {
		movie := MovieData{
			id: stringToInt(record[0]),
			title: record[1],
			voteAverage: stringToFloat(record[2]),
			voteCount: stringToInt(record[3]), 
			status: record[4],
			release_date: record[5],
			revenue: stringToInt(record[6]), 
			length: stringToInt(record[7]), 
			adult: stringToBool(record[8]),
			backdrop_path: record[9],
			budget: stringToInt(record[10]) ,
			homepage: record[11],
			imdbId: record[12],
			original_language: record[13],
			original_title: record[14],
			overview: record[15],
			popularity: record[16],
			poster_path: record[17],
			tagline: record[18],
			genres: record[19],
			production_companies: record[20],
			production_countries: record[21],
			spoken_languages: record[22],
			keywords: record[23],
		}
		movies = append(movies, movie)
	}
	return movies
}

func insertData(db *sql.DB, movies []MovieData) {
	for _, movie := range movies {
			sql := `
				insert INTO movies(id,
				title,
				voteAverage,
				voteCount,
				status,
				release_date,
				revenue,
				length,
				adult,
				backdrop_path,
				budget,
				homepage,
				imdbId,
				original_language,
				original_title,
				overview,
				popularity,
				poster_path,
				tagline,
				genres,
				production_companies,
				production_countries,
				spoken_languages,
				keywords)

				VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
			`
		_, err := db.Exec(sql, movie.id, movie.title, movie.voteAverage, movie.voteCount, movie.status, movie.release_date, movie.revenue, movie.length, movie.adult, movie.backdrop_path, movie.budget, movie.homepage, movie.imdbId, movie.original_language, movie.original_title, movie.overview, movie.popularity, movie.poster_path, movie.tagline, movie.genres, movie.production_companies, movie.production_countries, movie.spoken_languages, movie.keywords)
		if err != nil {
			fmt.Println(err)
        }
	}
}

func createTable(db *sql.DB){
	sql := `
		  CREATE TABLE IF NOT EXISTS movies (
			id INT NOT NULL PRIMARY KEY,
			title TEXT,
			voteAverage FLOAT,
			voteCount INT,
			status TEXT,
			release_date TEXT,
			revenue INT,
			length INT,
			adult BOOL,
			backdrop_path TEXT,
			budget INT,
			homepage TEXT,
			imdbId TEXT,
			original_language TEXT,
			original_title TEXT,
			overview TEXT,
			popularity TEXT,
			poster_path TEXT,
			tagline TEXT,
			genres TEXT,
			production_companies TEXT,
			production_countries TEXT,
			spoken_languages TEXT,
			keywords TEXT
		  );
	`

	_, err := db.Exec(sql)
	if err != nil {
        fmt.Println(err)
    }
}